package store

import (
	"database/sql"
	"fmt"
	"time"
)

type MySQLStore struct {
	BaseStore
}

func NewMySQLStore(db *sql.DB) *MySQLStore {
	return &MySQLStore{
		BaseStore: NewBaseStore(db),
	}
}

func (s *MySQLStore) Initialize() error {
	// Create table if not exists
	createTable := `
	CREATE TABLE IF NOT EXISTS read_events (
		message_id VARCHAR(255) NOT NULL,
		user_id VARCHAR(255) NOT NULL,
		channel_id VARCHAR(255) NOT NULL,
		timestamp BIGINT NOT NULL,
		PRIMARY KEY (message_id, user_id)
	)
	`
	if _, err := s.db.Exec(createTable); err != nil {
		return err
	}

	// Create indices if they don't exist (MySQL-safe way)
	indices := []string{
		"CREATE INDEX idx_read_events_message_id ON read_events(message_id)",
		"CREATE INDEX idx_read_events_user_id ON read_events(user_id)",
		"CREATE INDEX idx_read_events_channel_id ON read_events(channel_id)",
	}

	for _, idx := range indices {
		// Ignore errors as they likely mean the index already exists
		s.db.Exec(idx)
	}

	return nil
}

func (s *MySQLStore) Upsert(event ReadEvent) error {
	query := `
		INSERT INTO read_events (message_id, user_id, channel_id, timestamp)
		VALUES (?, ?, ?, ?)
		ON DUPLICATE KEY UPDATE timestamp = VALUES(timestamp)
	`
	_, err := s.db.Exec(query, event.MessageID, event.UserID, event.ChannelID, event.Timestamp)
	return err
}

func (s *MySQLStore) GetByChannel(channelID, excludeUserID string) ([]ReadEvent, error) {
	query := `
		SELECT message_id, user_id, channel_id, timestamp
		FROM read_events
		WHERE channel_id = ?
		AND user_id != ?
		ORDER BY timestamp DESC
	`

	rows, err := s.db.Query(query, channelID, excludeUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var events []ReadEvent
	for rows.Next() {
		var event ReadEvent
		if err := rows.Scan(&event.MessageID, &event.UserID, &event.ChannelID, &event.Timestamp); err != nil {
			return nil, err
		}
		events = append(events, event)
	}
	return events, rows.Err()
}

func (s *MySQLStore) CleanupOlderThan(days int) error {
	cutoffMs := time.Now().AddDate(0, 0, -days).UnixMilli()

	// Execute each DELETE separately to avoid requiring multiStatements=true
	if _, err := s.db.Exec("DELETE FROM read_events WHERE timestamp < ?", cutoffMs); err != nil {
		return fmt.Errorf("failed to cleanup read_events: %w", err)
	}

	if _, err := s.db.Exec("DELETE FROM channel_reads WHERE last_seen_at < ?", cutoffMs); err != nil {
		return fmt.Errorf("failed to cleanup channel_reads: %w", err)
	}

	return nil
}

func (s *MySQLStore) BeginTx() (Tx, error) {
	return s.db.Begin()
}

func (s *MySQLStore) UpsertTx(tx Tx, event ReadEvent) error {
	sqlTx, ok := tx.(*sql.Tx)
	if !ok {
		return fmt.Errorf("invalid transaction type")
	}

	query := `
		INSERT INTO read_events (message_id, user_id, channel_id, timestamp)
		VALUES (?, ?, ?, ?)
		ON DUPLICATE KEY UPDATE
		timestamp = GREATEST(timestamp, VALUES(timestamp))
	`
	_, err := sqlTx.Exec(query, event.MessageID, event.UserID, event.ChannelID, event.Timestamp)
	return err
}
